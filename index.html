<!-- build time:Mon Aug 19 2019 18:31:52 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next muse use-motion" lang="en"><head><meta charset="UTF-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0"><link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.3.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"7.3.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},save_scroll:!1,copycode:{enable:!1,show_result:!1,style:null},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta property="og:type" content="website"><meta property="og:title" content="AnYing Blog By Hexo"><meta property="og:url" content="https://trustme.anyingiit.com/index.html"><meta property="og:site_name" content="AnYing Blog By Hexo"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="AnYing Blog By Hexo"><link rel="canonical" href="https://trustme.anyingiit.com/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,isPage:!1,isArchive:!1}</script><title>AnYing Blog By Hexo</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">AnYing Blog By Hexo</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content page-home"><section id="posts" class="posts-expand"><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/18/压缩内容-加快访问速度/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/18/压缩内容-加快访问速度/" class="post-title-link" itemprop="url">压缩内容,加快访问速度</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-18 17:58:48 / Modified: 18:01:06" itemprop="dateCreated datePublished" datetime="2019-08-18T17:58:48+08:00">2019-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="安装hexo-neat插件"><a href="#安装hexo-neat插件" class="headerlink" title="安装hexo-neat插件"></a>安装<code>hexo-neat</code>插件</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-neat --save</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>_config.yml</code>文件末尾加入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat压缩插件</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js(这里我给禁用了压缩js,因为已开启就报错,未来有机会再解决吧!)</span><br><span class="line">neat_js:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/18/为next配置图片放大插件/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/18/为next配置图片放大插件/" class="post-title-link" itemprop="url">为next配置图片放大插件</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-18 17:01:49 / Modified: 17:06:06" itemprop="dateCreated datePublished" datetime="2019-08-18T17:01:49+08:00">2019-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="安装fancybox插件"><a href="#安装fancybox插件" class="headerlink" title="安装fancybox插件"></a>安装fancybox插件</h1><h3 id="切换到lib目录"><a href="#切换到lib目录" class="headerlink" title="切换到lib目录"></a>切换到lib目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nex/source/lib</span><br></pre></td></tr></table></figure><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure><h3 id="生效插件"><a href="#生效插件" class="headerlink" title="生效插件"></a>生效插件</h3><p>更改next/_config.yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p><img src="/2019/08/18/为next配置图片放大插件/%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C.gif" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/17/使用docker部署几个常见的HTTP服务/" class="post-title-link" itemprop="url">使用docker部署几个常见的HTTP服务</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-17 18:43:04" itemprop="dateCreated datePublished" datetime="2019-08-17T18:43:04+08:00">2019-08-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-18 17:58:03" itemprop="dateModified" datetime="2019-08-18T17:58:03+08:00">2019-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="doker解决了什么问题"><a href="#doker解决了什么问题" class="headerlink" title="doker解决了什么问题"></a>doker解决了什么问题</h2><p>不同的应用程序有不同的依赖环境,如果把他们的以来软件都安装在一个服务器上要调试很久,而且很麻烦,常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。<strong>docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小</strong>.</p><h2 id="doker和传统虚拟机相比有什么区别"><a href="#doker和传统虚拟机相比有什么区别" class="headerlink" title="doker和传统虚拟机相比有什么区别"></a>doker和传统虚拟机相比有什么区别</h2><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，<strong>容器内没有自己的内核，而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/virtualization.png" alt="传统虚拟化">传统虚拟化</p><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/docker.png" alt="Docker">Docker</p><h2 id="doker基本概念"><a href="#doker基本概念" class="headerlink" title="doker基本概念"></a>doker基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><h1 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>由于博主的服务器是Centos,所以以下是Centos的安装过程</p><h3 id="安装依赖包："><a href="#安装依赖包：" class="headerlink" title="安装依赖包："></a>安装依赖包：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm22</span><br></pre></td></tr></table></figure><h3 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装DockerCE"><a href="#安装DockerCE" class="headerlink" title="安装DockerCE"></a>安装DockerCE</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="启动docker-CE"><a href="#启动docker-CE" class="headerlink" title="启动docker CE"></a>启动docker CE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="验证是否安装正确"><a href="#验证是否安装正确" class="headerlink" title="验证是否安装正确"></a>验证是否安装正确</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@iz2ze9t07tpudth4raqstiz ~# docker run hello-world</span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/4B82DE75-73B9-45be-B111-BC8B96F83AFC.png" alt></p><h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p><code>/etc/docker/daemon.json</code> 中写入如下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/596E8A72-6861-49e2-93A4-9C8089CEC800.png" alt></p><h4 id="验证加速是否生效"><a href="#验证加速是否生效" class="headerlink" title="验证加速是否生效"></a>验证加速是否生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>检查回显是否包含如下内容,包含则配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/8A61A41D-42F2-4f83-8EB1-94712FE07B85.png" alt></p><h2 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h2><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从docker镜像仓库获取镜像的命令是<code>docker pull</code> 该命令的格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，<strong>如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像</strong>。</li></ul><h3 id="获取Ubuntu镜像并交互操作"><a href="#获取Ubuntu镜像并交互操作" class="headerlink" title="获取Ubuntu镜像并交互操作"></a>获取Ubuntu镜像并交互操作</h3><h4 id="从官方-docker-hub-获取镜像"><a href="#从官方-docker-hub-获取镜像" class="headerlink" title="从官方(docker hub)获取镜像"></a>从官方(<code>docker hub</code>)获取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:18.04</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm \</span></span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/# cat /etc/os-release</span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="18.04.1 LTS (Bionic Beaver)"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 18.04.1 LTS"</span><br><span class="line">VERSION_ID="18.04"</span><br><span class="line">HOME_URL="https://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="https://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"</span><br><span class="line">PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>使用<code>exit</code>退出容器</p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>使用<code>docker image ls</code>可以列出已下载镜像</p><p>注:可以直接使用<code>docker images</code>命令,等同于<code>docker image ls</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               a2a15febcdf3        2 days ago          64.2MB</span><br><span class="line">hello-world         latest              fce289e99eb9        7 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>使用<code>docker system df</code>查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   1                   64.19MB             64.19MB (99%)</span><br><span class="line">Containers          4                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>使用<code>docker image ls xxx</code>列出部分镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xxx              18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">xxx              latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><blockquote><p>主要参考:<a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a></p></blockquote><h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器的方式有两种:</p><ul><li>新建一个容器并启动</li><li>将终止状态(stopped)的容器重新启动</li></ul><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需命令<code>docker run</code></p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/054070DA-FD3E-43ae-9B21-2A80A8ED8596.png" alt></p><p><em>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</em></p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><blockquote><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ docker run ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p></blockquote><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d  ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br><span class="line">925cdc8f9b3916b68b222e6447daedf64137d3f2de54a0b6842c54475520901b</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker container logs</code> 查看)。</p><h4 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a><code>docker container logs</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [container ID or NAMES]</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">925cdc8f9b39        ubuntu:18.04        "/bin/sh -c 'while t…"   41 seconds ago      Up 40 seconds</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/A4E1AB94-5B71-40ac-9F95-94B7B49D04A7.png" alt></p><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p><strong>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</strong></p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用<code>-d</code>参数时,容器启动后悔进入后台.</p><p>厚些时候需要进入容器进行操作时,可用的命令有<code>docker attach</code>以及<code>docker exec</code>,推荐使用<code>docker exec</code></p><h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -dit ubuntu</span></span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker attach 243c</span></span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818164032.png" alt></p><p><em>注意:如果在标准输入(stdin)中<code>exit</code>会导致容器的停止</em></p><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec</code>命令</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818163620.png" alt></p><p><strong>如果从这个 stdin 中 exit，不会导致容器的停止。</strong></p><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">"/bin/bash"</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><p><em>注：用户既可以使用 <code>docker load</code>来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照((<code>docker import</code>)文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件(<code>docker load</code>)将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165307.png" alt></p><h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165406.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/" class="post-title-link" itemprop="url">使用Charles获取网易云网页端以及手机端的API地址</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-16 21:41:42" itemprop="dateCreated datePublished" datetime="2019-08-16T21:41:42+08:00">2019-08-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-17 12:20:06" itemprop="dateModified" datetime="2019-08-17T12:20:06+08:00">2019-08-17</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="获取网页端网页云API地址"><a href="#获取网页端网页云API地址" class="headerlink" title="获取网页端网页云API地址"></a>获取网页端网页云API地址</h1><h2 id="启动Charles代理"><a href="#启动Charles代理" class="headerlink" title="启动Charles代理"></a>启动Charles代理</h2><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/2C8393AE-0347-4e84-AE41-66CC5ED172E7.png" alt="启动Charles代理"></p><h2 id="捕获目标"><a href="#捕获目标" class="headerlink" title="捕获目标"></a>捕获目标</h2><h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/AB3ED844-484E-4bd2-8576-3AC08C10B2A9.png" alt></p><h3 id="捕获目标-1"><a href="#捕获目标-1" class="headerlink" title="捕获目标!"></a>捕获目标!</h3><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/86A90765-A333-42fb-9ABF-5202E907478D.png" alt="发现目标"></p><p>通过信息可以得出,网页端网易云音乐使用的接口为HTTPS,所以我们的下一步就是配置SSL,以捕获加密数据</p><h2 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h2><h3 id="安装Charles-SSL证书"><a href="#安装Charles-SSL证书" class="headerlink" title="安装Charles SSL证书"></a>安装Charles SSL证书</h3><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/Windows%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6.png" alt="Widows安装证书"></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/1ECEADD1-5F79-4482-B1A1-5EA5969A8D21.png" alt="安装证书"></p><ul><li>这里的过程非常容易,下一步即可,不做过多赘述</li></ul><h3 id="在Charles启用对https-music-163-com的SSL代理"><a href="#在Charles启用对https-music-163-com的SSL代理" class="headerlink" title="在Charles启用对https://music.163.com的SSL代理"></a>在Charles启用对<code>https://music.163.com</code>的SSL代理</h3><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/27A5F2B6-1107-4e0f-BD2E-3A5CC8C65AEF.png" alt></p><h4 id="对目标进行锁定"><a href="#对目标进行锁定" class="headerlink" title="对目标进行锁定"></a>对目标进行锁定</h4><p>计算机在无时不刻发送数据,导致我们的Charles非常清爽,所以我们需要锁定目标</p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/8767E233-3F28-4965-ACC0-A1B31B81F6FE.png" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/64082E39-C5AB-4995-9BEB-71CEE576A2A6.png" alt></p><p>是不是清爽了许多!!</p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ul><li>在刷新网易云音乐页面后提示页面不安全,可能被攻击.嗯,从某种意义来说就是这样,我们不管他</li></ul><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/31F96670-A07E-4eb5-AA0A-C071EEA8117E.png" alt></p><ul><li>观察api请求结构</li></ul><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/94E564D0-3B97-41e1-83E7-2CC97727BADE.png" alt></p><ul><li>锁定目标</li></ul><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/03E6D4CF-5DF3-4b7b-8031-B7DA87D7C786.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>获取音乐本体URL的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params:HfkwofZ8nsUxNEBLvPBxyrliRdcVJ+zP2fsiziSHhAN5OHPlQrjJPlMvBdv75FWMVyPL59fnorFkThrphcqrmICEgJEXzOUgop6FbwGaCPtJxmh9raoYNuUMxBqNpu9PD15IXmaiVxmhTjg6AnSfHg==</span><br><span class="line">encSecKey:5ef720b71a5307a47eb34a7ec3e1862f75d355a673d3a452354c168db11869d2e65d09e1a098f62a30cec61092622b62aa8ecff3d3b5ac556ef76eaaecd7776bb71b2a278852e9f5665212feefb094a573f0215ee9d44fc909fef5e5cefdd5bb795d4023f0d543f8763337fe10e9fbe66f650fe620d29e440cc0afb8f0f7f5ad</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/19F9FAF3-A7DD-48c6-88AB-98A0D4CDFC59.png" alt></p><h1 id="获取安卓网易云APP-API地址"><a href="#获取安卓网易云APP-API地址" class="headerlink" title="获取安卓网易云APP-API地址"></a>获取安卓网易云APP-API地址</h1><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/D53EE0BF-9AE6-495c-BAC7-E2989F63ACF5.png" alt></p><ul><li>将手机置于和pc同一局域网下</li></ul><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/527356C7-CE75-468f-9388-E2B4E2DAC37A.png" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/ACED164E-3705-4735-B046-C18CB790005D.png" alt="检测到手机尝试连接代理"></p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/78C999A1-B8DB-41cd-9B18-67C6254C006D.png" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/90CEBAC0-AF37-43de-900C-66E579FBA27B.png" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/IMG_20190817_114325.jpg" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/IMG_20190817_114338.jpg" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/IMG_20190817_114536.jpg" alt></p><p>√Done!</p><h2 id="正式开始-1"><a href="#正式开始-1" class="headerlink" title="正式开始"></a>正式开始</h2><p>在刷新几次页面后观察列表,发现<code>interface.music.163.com</code>的接口结构和刚刚网页端网易云音乐的目标接口接口及其相似</p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/7777E1CB-5849-4c8e-AA9B-2BF0E0092ACC.png" alt></p><p>几次尝试之后锁定了<code>http://interface3.music.163.com/eapi/song/enhance/player/url/v1?ids=%5B%22536622304_0%22%2C%22537470060_0%22%5D&amp;level=exhigh&amp;encodeType=aac</code></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/09B2ED66-93C2-4c73-AA6F-49A71FADACEB.png" alt="不过这一大坨是什么东西"></p><p>不过这以大坨是什么东西..</p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/D886B86B-C7AE-46cc-8EC4-1391C42F4898.png" alt></p><p>内容编码格式为gzip,难道和这个有关?</p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/7C62E4B8-1405-47ea-9F32-B451DB006D2C.png" alt></p><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/33564D6A-74F2-40b8-8FC4-828D15EF13BF.png" alt></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>API本体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://interface3.music.163.com/eapi/song/enhance/player/url/v1?ids=%5B%22536622304_0%22%2C%22537470060_0%22%5D&amp;level=exhigh&amp;encodeType=aac</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params=FA90B329E9614F79E79598F37DC2EDB487F00D1BC4C9B24CD57E6C318B90735683B31EBCEA2406A063CEA88FC25A3AF31F5AE062C154E354DE501E2FABA37F00CD5764981144AC2E56A8AC59D6F4133F6F4461CDA1CF73753380189AA21E8AB50A123DFC9CAB93F40C935CF84CD10D6DF5B2D7DA80ADA61A7F7F5A2F3A608221553A5F9DB5944F3CC013987127041C75588E1634CC12A893E605B06325FC92A516D1E588E00C3DCE6E0A53EB173D39F97CA037707AB40CCF7F93044ACBD8235C03ADE6CC06114148244F5C19DA7905873D4997C8C78628031375F49E8B68CB93327B9206F391DC49E69F1672B30605CD4F5B95AC55800D593466BE116C870A0E8AB62C7BDC11091FF435E59684EB7E277DB6812B495A61571B7CAF8C54EF7456881F67FE66B6FCCADFF268EDD4A4C4DB1517E05A2D5EC0E61A2039C1E79CD007315D001712F055117E10CD02B8438A56BABDB0E88EAD74FA6873025EFE3BF1EB4111ED282DB085F3DE47325A84ADDC879815CD43514120820C821D1648CB1DE16446514C72161B30F1B77E72CC011770CF5B8DD0C0B7FD127C526211D4B3FF74DCB5494E0ABC6A2DB7AA5211661612491D569742CDEF98F112244CAB8EDAA831D0453954A3B7FFC43C1D2CFA21DA4D82C89D8DD2D46E5E0BA1FBE8DF6E956BF54894D9CF7EC29C4A84CF5D4AF27D1B758048AF9D3CE4BF3189ABEBB0E7015B60B460EFFBD617C78448B4470C6B53A198529E2E9860A3E4012D6419579E81686A6C997E67CE2E4C5E7256D5C9B731C1149D7E72EBF4E414922DF6A739ED34ED7F6EEC5F8B757E2D1C6C187F613118ED4386870F333EFF03967845824CEB3390B7D8BAA052F1854D973C4F33312C905A8F593736B9D1B3B7776053D997B7247F02D8123DF0F56A7C53FC2BFBE9BBBA376D6343AB55D372C515C620A1EFCC126D18</span><br></pre></td></tr></table></figure><p>根据返回的这一大坨来看,应该不是服务器报错,但是我们看到的依然是乱码,基本上可以判定该接口返回的数据为加密数据.</p><h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p><img src="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/33564D6A-74F2-40b8-8FC4-828D15EF13BF.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="网页端API接口"><a href="#网页端API接口" class="headerlink" title="网页端API接口"></a>网页端API接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params:HfkwofZ8nsUxNEBLvPBxyrliRdcVJ+zP2fsiziSHhAN5OHPlQrjJPlMvBdv75FWMVyPL59fnorFkThrphcqrmICEgJEXzOUgop6FbwGaCPtJxmh9raoYNuUMxBqNpu9PD15IXmaiVxmhTjg6AnSfHg==</span><br><span class="line">encSecKey:5ef720b71a5307a47eb34a7ec3e1862f75d355a673d3a452354c168db11869d2e65d09e1a098f62a30cec61092622b62aa8ecff3d3b5ac556ef76eaaecd7776bb71b2a278852e9f5665212feefb094a573f0215ee9d44fc909fef5e5cefdd5bb795d4023f0d543f8763337fe10e9fbe66f650fe620d29e440cc0afb8f0f7f5ad</span><br></pre></td></tr></table></figure><h2 id="移动端API接口"><a href="#移动端API接口" class="headerlink" title="移动端API接口"></a>移动端API接口</h2><p>API本体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://interface3.music.163.com/eapi/song/enhance/player/url/v1?ids=%5B%22536622304_0%22%2C%22537470060_0%22%5D&amp;level=exhigh&amp;encodeType=aac</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params=FA90B329E9614F79E79598F37DC2EDB487F00D1BC4C9B24CD57E6C318B90735683B31EBCEA2406A063CEA88FC25A3AF31F5AE062C154E354DE501E2FABA37F00CD5764981144AC2E56A8AC59D6F4133F6F4461CDA1CF73753380189AA21E8AB50A123DFC9CAB93F40C935CF84CD10D6DF5B2D7DA80ADA61A7F7F5A2F3A608221553A5F9DB5944F3CC013987127041C75588E1634CC12A893E605B06325FC92A516D1E588E00C3DCE6E0A53EB173D39F97CA037707AB40CCF7F93044ACBD8235C03ADE6CC06114148244F5C19DA7905873D4997C8C78628031375F49E8B68CB93327B9206F391DC49E69F1672B30605CD4F5B95AC55800D593466BE116C870A0E8AB62C7BDC11091FF435E59684EB7E277DB6812B495A61571B7CAF8C54EF7456881F67FE66B6FCCADFF268EDD4A4C4DB1517E05A2D5EC0E61A2039C1E79CD007315D001712F055117E10CD02B8438A56BABDB0E88EAD74FA6873025EFE3BF1EB4111ED282DB085F3DE47325A84ADDC879815CD43514120820C821D1648CB1DE16446514C72161B30F1B77E72CC011770CF5B8DD0C0B7FD127C526211D4B3FF74DCB5494E0ABC6A2DB7AA5211661612491D569742CDEF98F112244CAB8EDAA831D0453954A3B7FFC43C1D2CFA21DA4D82C89D8DD2D46E5E0BA1FBE8DF6E956BF54894D9CF7EC29C4A84CF5D4AF27D1B758048AF9D3CE4BF3189ABEBB0E7015B60B460EFFBD617C78448B4470C6B53A198529E2E9860A3E4012D6419579E81686A6C997E67CE2E4C5E7256D5C9B731C1149D7E72EBF4E414922DF6A739ED34ED7F6EEC5F8B757E2D1C6C187F613118ED4386870F333EFF03967845824CEB3390B7D8BAA052F1854D973C4F33312C905A8F593736B9D1B3B7776053D997B7247F02D8123DF0F56A7C53FC2BFBE9BBBA376D6343AB55D372C515C620A1EFCC126D18</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/16/Into-Hexo-Blog-Inset-Image/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/16/Into-Hexo-Blog-Inset-Image/" class="post-title-link" itemprop="url">Into Hexo Blog Inset Image</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-16 20:54:12 / Modified: 21:38:37" itemprop="dateCreated datePublished" datetime="2019-08-16T20:54:12+08:00">2019-08-16</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="在Hexo博客中添加图片"><a href="#在Hexo博客中添加图片" class="headerlink" title="在Hexo博客中添加图片"></a>在Hexo博客中添加图片</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在Hexo博客根目录安装<code>hexo-asset-image</code>插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> npm install hexo-asset-image --save#我信你个鬼,这个版本太老了,用下面的命令</span><br><span class="line">npm install https://github.com/xcodebuild/hexo-asset-image.git</span><br></pre></td></tr></table></figure><h2 id="配置自动创建文件夹"><a href="#配置自动创建文件夹" class="headerlink" title="配置自动创建文件夹"></a>配置自动创建文件夹</h2><p>在<code>_config.yml</code>修改<code>post_asset_folder: true</code>以在创建新文章的时候自动创建同名文件夹</p><h2 id="图片效果展示"><a href="#图片效果展示" class="headerlink" title="图片效果展示"></a>图片效果展示</h2><p><img src="/2019/08/16/Into-Hexo-Blog-Inset-Image/Mercy.jpg" alt="Mercy"></p><h1 id="等等-好像没那么容易结束…"><a href="#等等-好像没那么容易结束…" class="headerlink" title="等等!好像没那么容易结束…"></a>等等!好像没那么容易结束…</h1><p>原本文章在这里就结束了,作者本来只想简单的记录一下设置图片的过程,没想到踩了一个大坑!也许你注意到了,上面的安装<code>hexo-asset-image</code>的代码第一行被注释掉了,作者弄了两个小时,就是无法生成正确的引用图片地址,气死我了,各种升级依赖,各种google,然后发现就是以前的版本有一个生成Bug,导致图片的位置一直引用的地址为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src="/.com//xxPic.jpg"</span><br></pre></td></tr></table></figure><p>气死我了,希望看到文章的您不要再使用<code>npm install hexo-asset-image --seve</code>了!!</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/13/解决解析域名到xxx-github-io后一提交就会导致绑定失效/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/13/解决解析域名到xxx-github-io后一提交就会导致绑定失效/" class="post-title-link" itemprop="url">解决解析域名到xxx.github.io后一提交就会导致绑定失效</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-13 11:38:03 / Modified: 11:39:17" itemprop="dateCreated datePublished" datetime="2019-08-13T11:38:03+08:00">2019-08-13</time></span></div></header><div class="post-body" itemprop="articleBody"><p>​ 经过多方排查,最终发现是我的source目录下的CNAME错误的写成了”CHAME”导致的,更名重新提交后文件解决~</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/12/Hello-World/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/12/Hello-World/" class="post-title-link" itemprop="url">Hello World</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-12 21:15:56 / Modified: 21:22:41" itemprop="dateCreated datePublished" datetime="2019-08-12T21:15:56+08:00">2019-08-12</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>欢迎你,陌生人</p><p>当你看到该页面时说明我已经成功利用github创建了一个Hexo博客站点,而您能看到这个这个标题说明我对如下操作有了了解:</p><ul><li>Linux 的基本使用</li><li><em>Markdown语法的</em>基本使用</li><li><code>npm</code>的基本使用</li><li><code>hexo</code>的基本使用</li><li>域名基本的解析</li><li>对博客结构有一定了解</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">John Doe</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">posts</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">John Doe</span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script><script src="/js/schemes/muse.js?v=7.3.0"></script><script src="/js/next-boot.js?v=7.3.0"></script></body></html><!-- rebuild by neat -->