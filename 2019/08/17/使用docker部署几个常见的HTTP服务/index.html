<!-- build time:Tue Aug 20 2019 10:26:33 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next muse use-motion" lang="en"><head><meta charset="UTF-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0"><link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.3.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"7.3.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},save_scroll:!1,copycode:{enable:!1,show_result:!1,style:null},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta name="description" content="docker简介doker解决了什么问题不同的应用程序有不同的依赖环境,如果把他们的以来软件都安装在一个服务器上要调试很久,而且很麻烦,常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小.doker和传统虚拟机相比有什么区别Docker 在容器的基础上，进行了进一步的封装，从文件系统、网"><meta property="og:type" content="article"><meta property="og:title" content="使用docker部署几个常见的HTTP服务"><meta property="og:url" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/index.html"><meta property="og:site_name" content="AnYing Blog By Hexo"><meta property="og:description" content="docker简介doker解决了什么问题不同的应用程序有不同的依赖环境,如果把他们的以来软件都安装在一个服务器上要调试很久,而且很麻烦,常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小.doker和传统虚拟机相比有什么区别Docker 在容器的基础上，进行了进一步的封装，从文件系统、网"><meta property="og:locale" content="en"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/virtualization.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/docker.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/4B82DE75-73B9-45be-B111-BC8B96F83AFC.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/596E8A72-6861-49e2-93A4-9C8089CEC800.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/8A61A41D-42F2-4f83-8EB1-94712FE07B85.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/054070DA-FD3E-43ae-9B21-2A80A8ED8596.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/A4E1AB94-5B71-40ac-9F95-94B7B49D04A7.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818164032.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818163620.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165307.png"><meta property="og:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165406.png"><meta property="og:updated_time" content="2019-08-18T09:58:03.743Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用docker部署几个常见的HTTP服务"><meta name="twitter:description" content="docker简介doker解决了什么问题不同的应用程序有不同的依赖环境,如果把他们的以来软件都安装在一个服务器上要调试很久,而且很麻烦,常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小.doker和传统虚拟机相比有什么区别Docker 在容器的基础上，进行了进一步的封装，从文件系统、网"><meta name="twitter:image" content="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/virtualization.png"><link rel="canonical" href="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>使用docker部署几个常见的HTTP服务 | AnYing Blog By Hexo</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">AnYing Blog By Hexo</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content page-post-detail"><div id="posts" class="posts-expand"><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/17/使用docker部署几个常见的HTTP服务/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">使用docker部署几个常见的HTTP服务</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-17 18:43:04" itemprop="dateCreated datePublished" datetime="2019-08-17T18:43:04+08:00">2019-08-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-18 17:58:03" itemprop="dateModified" datetime="2019-08-18T17:58:03+08:00">2019-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="doker解决了什么问题"><a href="#doker解决了什么问题" class="headerlink" title="doker解决了什么问题"></a>doker解决了什么问题</h2><p>不同的应用程序有不同的依赖环境,如果把他们的以来软件都安装在一个服务器上要调试很久,而且很麻烦,常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。<strong>docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小</strong>.</p><h2 id="doker和传统虚拟机相比有什么区别"><a href="#doker和传统虚拟机相比有什么区别" class="headerlink" title="doker和传统虚拟机相比有什么区别"></a>doker和传统虚拟机相比有什么区别</h2><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，<strong>容器内没有自己的内核，而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/virtualization.png" alt="传统虚拟化">传统虚拟化</p><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/docker.png" alt="Docker">Docker</p><h2 id="doker基本概念"><a href="#doker基本概念" class="headerlink" title="doker基本概念"></a>doker基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><h1 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>由于博主的服务器是Centos,所以以下是Centos的安装过程</p><h3 id="安装依赖包："><a href="#安装依赖包：" class="headerlink" title="安装依赖包："></a>安装依赖包：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm22</span><br></pre></td></tr></table></figure><h3 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装DockerCE"><a href="#安装DockerCE" class="headerlink" title="安装DockerCE"></a>安装DockerCE</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="启动docker-CE"><a href="#启动docker-CE" class="headerlink" title="启动docker CE"></a>启动docker CE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="验证是否安装正确"><a href="#验证是否安装正确" class="headerlink" title="验证是否安装正确"></a>验证是否安装正确</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@iz2ze9t07tpudth4raqstiz ~# docker run hello-world</span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/4B82DE75-73B9-45be-B111-BC8B96F83AFC.png" alt></p><h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p><code>/etc/docker/daemon.json</code> 中写入如下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/596E8A72-6861-49e2-93A4-9C8089CEC800.png" alt></p><h4 id="验证加速是否生效"><a href="#验证加速是否生效" class="headerlink" title="验证加速是否生效"></a>验证加速是否生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>检查回显是否包含如下内容,包含则配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/8A61A41D-42F2-4f83-8EB1-94712FE07B85.png" alt></p><h2 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h2><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从docker镜像仓库获取镜像的命令是<code>docker pull</code> 该命令的格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，<strong>如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像</strong>。</li></ul><h3 id="获取Ubuntu镜像并交互操作"><a href="#获取Ubuntu镜像并交互操作" class="headerlink" title="获取Ubuntu镜像并交互操作"></a>获取Ubuntu镜像并交互操作</h3><h4 id="从官方-docker-hub-获取镜像"><a href="#从官方-docker-hub-获取镜像" class="headerlink" title="从官方(docker hub)获取镜像"></a>从官方(<code>docker hub</code>)获取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:18.04</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm \</span></span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/# cat /etc/os-release</span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="18.04.1 LTS (Bionic Beaver)"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 18.04.1 LTS"</span><br><span class="line">VERSION_ID="18.04"</span><br><span class="line">HOME_URL="https://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="https://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"</span><br><span class="line">PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>使用<code>exit</code>退出容器</p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>使用<code>docker image ls</code>可以列出已下载镜像</p><p>注:可以直接使用<code>docker images</code>命令,等同于<code>docker image ls</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               a2a15febcdf3        2 days ago          64.2MB</span><br><span class="line">hello-world         latest              fce289e99eb9        7 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>使用<code>docker system df</code>查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   1                   64.19MB             64.19MB (99%)</span><br><span class="line">Containers          4                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>使用<code>docker image ls xxx</code>列出部分镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xxx              18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">xxx              latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><blockquote><p>主要参考:<a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a></p></blockquote><h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器的方式有两种:</p><ul><li>新建一个容器并启动</li><li>将终止状态(stopped)的容器重新启动</li></ul><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需命令<code>docker run</code></p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/054070DA-FD3E-43ae-9B21-2A80A8ED8596.png" alt></p><p><em>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</em></p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><blockquote><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ docker run ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p></blockquote><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d  ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br><span class="line">925cdc8f9b3916b68b222e6447daedf64137d3f2de54a0b6842c54475520901b</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker container logs</code> 查看)。</p><h4 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a><code>docker container logs</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [container ID or NAMES]</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">925cdc8f9b39        ubuntu:18.04        "/bin/sh -c 'while t…"   41 seconds ago      Up 40 seconds</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/A4E1AB94-5B71-40ac-9F95-94B7B49D04A7.png" alt></p><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p><strong>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</strong></p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用<code>-d</code>参数时,容器启动后悔进入后台.</p><p>厚些时候需要进入容器进行操作时,可用的命令有<code>docker attach</code>以及<code>docker exec</code>,推荐使用<code>docker exec</code></p><h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -dit ubuntu</span></span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker attach 243c</span></span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818164032.png" alt></p><p><em>注意:如果在标准输入(stdin)中<code>exit</code>会导致容器的停止</em></p><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec</code>命令</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818163620.png" alt></p><p><strong>如果从这个 stdin 中 exit，不会导致容器的停止。</strong></p><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">"/bin/bash"</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><p><em>注：用户既可以使用 <code>docker load</code>来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照((<code>docker import</code>)文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件(<code>docker load</code>)将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165307.png" alt></p><h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure><p><img src="/2019/08/17/使用docker部署几个常见的HTTP服务/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165406.png" alt></p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/" rel="next" title="使用Charles获取网易云网页端以及手机端的API地址"><i class="fa fa-chevron-left"></i> 使用Charles获取网易云网页端以及手机端的API地址</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/08/18/为next配置图片放大插件/" rel="prev" title="为next配置图片放大插件">为next配置图片放大插件 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">John Doe</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">posts</span></a></div></nav></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#docker简介"><span class="nav-number">1.</span> <span class="nav-text">docker简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#doker解决了什么问题"><span class="nav-number">1.1.</span> <span class="nav-text">doker解决了什么问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#doker和传统虚拟机相比有什么区别"><span class="nav-number">1.2.</span> <span class="nav-text">doker和传统虚拟机相比有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#doker基本概念"><span class="nav-number">1.3.</span> <span class="nav-text">doker基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像"><span class="nav-number">1.3.1.</span> <span class="nav-text">镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器"><span class="nav-number">1.3.2.</span> <span class="nav-text">容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Registry"><span class="nav-number">1.4.</span> <span class="nav-text">Docker Registry</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用docker"><span class="nav-number">2.</span> <span class="nav-text">使用docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装docker"><span class="nav-number">2.1.</span> <span class="nav-text">安装docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装依赖包："><span class="nav-number">2.1.1.</span> <span class="nav-text">安装依赖包：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加软件源"><span class="nav-number">2.1.2.</span> <span class="nav-text">添加软件源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装DockerCE"><span class="nav-number">2.1.3.</span> <span class="nav-text">安装DockerCE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动docker-CE"><span class="nav-number">2.1.4.</span> <span class="nav-text">启动docker CE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证是否安装正确"><span class="nav-number">2.1.5.</span> <span class="nav-text">验证是否安装正确</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置镜像加速"><span class="nav-number">2.1.6.</span> <span class="nav-text">配置镜像加速</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#验证加速是否生效"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">验证加速是否生效</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像-1"><span class="nav-number">2.2.</span> <span class="nav-text">镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取镜像"><span class="nav-number">2.3.</span> <span class="nav-text">获取镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取Ubuntu镜像并交互操作"><span class="nav-number">2.3.1.</span> <span class="nav-text">获取Ubuntu镜像并交互操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从官方-docker-hub-获取镜像"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">从官方(docker hub)获取镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">运行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列出镜像"><span class="nav-number">2.3.2.</span> <span class="nav-text">列出镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除镜像"><span class="nav-number">2.3.3.</span> <span class="nav-text">删除镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器-1"><span class="nav-number">2.4.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动容器"><span class="nav-number">2.4.1.</span> <span class="nav-text">启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新建并启动"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">新建并启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动已终止容器"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">启动已终止容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后台运行"><span class="nav-number">2.4.2.</span> <span class="nav-text">后台运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-container-logs"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">docker container logs</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终止"><span class="nav-number">2.4.3.</span> <span class="nav-text">终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进入容器"><span class="nav-number">2.4.4.</span> <span class="nav-text">进入容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#attach命令"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">attach命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec命令"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">exec命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出和导入容器"><span class="nav-number">2.4.5.</span> <span class="nav-text">导出和导入容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导出容器"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">导出容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导入容器"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">导入容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-number">2.4.6.</span> <span class="nav-text">删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#删除容器"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清理所有处于终止状态的容器"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">清理所有处于终止状态的容器</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">John Doe</span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script><script src="/js/schemes/muse.js?v=7.3.0"></script><script src="/js/next-boot.js?v=7.3.0"></script><script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script></body></html><!-- rebuild by neat -->