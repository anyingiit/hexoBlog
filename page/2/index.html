<!-- build time:Tue Sep 24 2019 20:21:07 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next muse use-motion" lang="en"><head><meta charset="UTF-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0"><link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.3.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"7.3.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},save_scroll:!1,copycode:{enable:!1,show_result:!1,style:null},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta property="og:type" content="website"><meta property="og:title" content="AnYing Blog By Hexo"><meta property="og:url" content="https://trustme.anyingiit.com/page/2/index.html"><meta property="og:site_name" content="AnYing Blog By Hexo"><meta property="og:locale" content="en"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="AnYing Blog By Hexo"><link rel="canonical" href="https://trustme.anyingiit.com/page/2/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,isPage:!1,isArchive:!1}</script><title>AnYing Blog By Hexo</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">AnYing Blog By Hexo</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content page-home"><section id="posts" class="posts-expand"><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/20/配置git-page使用华为云CDN/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/20/配置git-page使用华为云CDN/" class="post-title-link" itemprop="url">配置git page使用华为云CDN</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-20 13:49:06" itemprop="dateCreated datePublished" datetime="2019-08-20T13:49:06+08:00">2019-08-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-21 09:28:11" itemprop="dateModified" datetime="2019-08-21T09:28:11+08:00">2019-08-21</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ol><li>有一个域名</li><li>配置好的git page<ol><li>域名指向</li><li>可以正常访问</li></ol></li><li>有CDN产品的华为云账号</li></ol><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h3 id="配置华为云"><a href="#配置华为云" class="headerlink" title="配置华为云"></a>配置华为云</h3><h4 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h4><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821091133.png" alt="得出源站IP"></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821090943.png" alt="添加域名"></p><h4 id="配置HTTPS"><a href="#配置HTTPS" class="headerlink" title="配置HTTPS"></a>配置HTTPS</h4><h5 id="申请证书并导入证书"><a href="#申请证书并导入证书" class="headerlink" title="申请证书并导入证书"></a>申请证书并导入证书</h5><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821091432.png" alt></p><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><h4 id="复制CNAME"><a href="#复制CNAME" class="headerlink" title="复制CNAME"></a>复制CNAME</h4><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821092531.png" alt></p><h4 id="配置CNAME"><a href="#配置CNAME" class="headerlink" title="配置CNAME"></a>配置CNAME</h4><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821092717.png" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/18/压缩内容-加快访问速度/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/18/压缩内容-加快访问速度/" class="post-title-link" itemprop="url">压缩内容,加快访问速度</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-18 17:58:48 / Modified: 18:01:06" itemprop="dateCreated datePublished" datetime="2019-08-18T17:58:48+08:00">2019-08-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="安装hexo-neat插件"><a href="#安装hexo-neat插件" class="headerlink" title="安装hexo-neat插件"></a>安装<code>hexo-neat</code>插件</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo-neat --save</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>_config.yml</code>文件末尾加入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat压缩插件</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js(这里我给禁用了压缩js,因为已开启就报错,未来有机会再解决吧!)</span><br><span class="line">neat_js:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/18/为next配置图片放大插件/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/18/为next配置图片放大插件/" class="post-title-link" itemprop="url">为next配置图片放大插件</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-18 17:01:49" itemprop="dateCreated datePublished" datetime="2019-08-18T17:01:49+08:00">2019-08-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-20 15:58:05" itemprop="dateModified" datetime="2019-08-20T15:58:05+08:00">2019-08-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="安装fancybox插件"><a href="#安装fancybox插件" class="headerlink" title="安装fancybox插件"></a>安装fancybox插件</h1><h3 id="切换到lib目录"><a href="#切换到lib目录" class="headerlink" title="切换到lib目录"></a>切换到lib目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nex/source/lib</span><br></pre></td></tr></table></figure><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure><h3 id="生效插件"><a href="#生效插件" class="headerlink" title="生效插件"></a>生效插件</h3><p>更改next/_config.yml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820155758.gif" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/17/doker学习日志/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/17/doker学习日志/" class="post-title-link" itemprop="url">Docker学习日志</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-17 18:43:04" itemprop="dateCreated datePublished" datetime="2019-08-17T18:43:04+08:00">2019-08-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-23 13:52:28" itemprop="dateModified" datetime="2019-08-23T13:52:28+08:00">2019-08-23</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="doker解决了什么问题"><a href="#doker解决了什么问题" class="headerlink" title="doker解决了什么问题"></a>doker解决了什么问题</h2><p>不同的应用程序有不同的依赖环境,如果把他们的以来软件都安装在一个服务器上要调试很久,而且很麻烦,常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。<strong>docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小</strong>.</p><h2 id="doker和传统虚拟机相比有什么区别"><a href="#doker和传统虚拟机相比有什么区别" class="headerlink" title="doker和传统虚拟机相比有什么区别"></a>doker和传统虚拟机相比有什么区别</h2><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，<strong>容器内没有自己的内核，而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便。</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/virtualization.png" alt="传统虚拟化">传统虚拟化</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/docker.png" alt="Docker">Docker</p><h2 id="doker基本概念"><a href="#doker基本概念" class="headerlink" title="doker基本概念"></a>doker基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><h1 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>由于博主的服务器是Centos,所以以下是Centos的安装过程</p><h3 id="安装依赖包："><a href="#安装依赖包：" class="headerlink" title="安装依赖包："></a>安装依赖包：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm22</span><br></pre></td></tr></table></figure><h3 id="添加软件源"><a href="#添加软件源" class="headerlink" title="添加软件源"></a>添加软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="安装DockerCE"><a href="#安装DockerCE" class="headerlink" title="安装DockerCE"></a>安装DockerCE</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="启动docker-CE"><a href="#启动docker-CE" class="headerlink" title="启动docker CE"></a>启动docker CE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="验证是否安装正确"><a href="#验证是否安装正确" class="headerlink" title="验证是否安装正确"></a>验证是否安装正确</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@iz2ze9t07tpudth4raqstiz ~# docker run hello-world</span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete </span><br><span class="line">Digest: sha256:6540fc08ee6e6b7b63468dc3317e3303aae178cb8a45ed3123180328bcc1d20f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/4B82DE75-73B9-45be-B111-BC8B96F83AFC.png" alt></p><h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p><code>/etc/docker/daemon.json</code> 中写入如下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/596E8A72-6861-49e2-93A4-9C8089CEC800.png" alt></p><h4 id="验证加速是否生效"><a href="#验证加速是否生效" class="headerlink" title="验证加速是否生效"></a>验证加速是否生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>检查回显是否包含如下内容,包含则配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/8A61A41D-42F2-4f83-8EB1-94712FE07B85.png" alt></p><h2 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从docker镜像仓库获取镜像的命令是<code>docker pull</code> 该命令的格式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，<strong>如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像</strong>。</li></ul><h3 id="获取Ubuntu镜像并交互操作"><a href="#获取Ubuntu镜像并交互操作" class="headerlink" title="获取Ubuntu镜像并交互操作"></a>获取Ubuntu镜像并交互操作</h3><h4 id="从官方-docker-hub-获取镜像"><a href="#从官方-docker-hub-获取镜像" class="headerlink" title="从官方(docker hub)获取镜像"></a>从官方(<code>docker hub</code>)获取镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:18.04</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm \</span></span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:/# cat /etc/os-release</span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="18.04.1 LTS (Bionic Beaver)"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 18.04.1 LTS"</span><br><span class="line">VERSION_ID="18.04"</span><br><span class="line">HOME_URL="https://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="https://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"</span><br><span class="line">PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>使用<code>exit</code>退出容器</p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>使用<code>docker image ls</code>可以列出已下载镜像</p><p>注:可以直接使用<code>docker images</code>命令,等同于<code>docker image ls</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               a2a15febcdf3        2 days ago          64.2MB</span><br><span class="line">hello-world         latest              fce289e99eb9        7 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>使用<code>docker system df</code>查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   1                   64.19MB             64.19MB (99%)</span><br><span class="line">Containers          4                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><p>使用<code>docker image ls xxx</code>列出部分镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xxx              18.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">xxx              latest              f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><h3 id="利用commit理解镜像构成"><a href="#利用commit理解镜像构成" class="headerlink" title="利用commit理解镜像构成"></a>利用<code>commit</code>理解镜像构成</h3><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，<strong>不要使用 <code>docker commit</code> 定制镜像</strong>，定制镜像应该使用 <code>Dockerfile</code> 来完成。</p><p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 801:80 nginx</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822154730.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822154837.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822154923.png" alt></p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code>命令进入容器，修改其内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it webserver bash</span><br><span class="line">root@3729b97e8226:/<span class="comment"># echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line">root@3729b97e8226:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822155158.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822155224.png" alt></p><h4 id="查看容器具体变动"><a href="#查看容器具体变动" class="headerlink" title="查看容器具体变动"></a>查看容器具体变动</h4><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker diff 985c50932839472e9589d268b133784fa0c189c5bcd8be219542c8d93e7ea4fe </span></span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br><span class="line">C /usr</span><br><span class="line">C /usr/share</span><br><span class="line">C /usr/share/nginx</span><br><span class="line">C /usr/share/nginx/html</span><br><span class="line">C /usr/share/nginx/html/index.html</span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br></pre></td></tr></table></figure><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><h4 id="docker-commit命令"><a href="#docker-commit命令" class="headerlink" title="docker commit命令"></a><code>docker commit</code>命令</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker commit \</span></span><br><span class="line">    --author "AnYing&lt;anyingiit@aliyun.com&gt;" \</span><br><span class="line">    --message "Edit index.html" \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br></pre></td></tr></table></figure><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822184637.png" alt></p><h6 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a><code>docker history</code></h6><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822184827.png" alt></p><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 802:80 nginx:v2</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822185023.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190822185404.png" alt></p><h5 id="慎用commit"><a href="#慎用commit" class="headerlink" title="慎用commit"></a>慎用<code>commit</code></h5><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><h3 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用<code>Dockerfile</code>定制镜像</h3><h4 id="why-Dockerfile"><a href="#why-Dockerfile" class="headerlink" title="why Dockerfile"></a>why <code>Dockerfile</code></h4><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个<strong>脚本</strong>，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。<strong>这个脚本就是 Dockerfile</strong>。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><h4 id="新建Dockerfile"><a href="#新建Dockerfile" class="headerlink" title="新建Dockerfile"></a>新建<code>Dockerfile</code></h4><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h4 id="Dockefile命令"><a href="#Dockefile命令" class="headerlink" title="Dockefile命令"></a><code>Dockefile</code>命令</h4><h5 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a><code>FROM</code>指定基础镜像</h5><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><h6 id="scratch空白镜像"><a href="#scratch空白镜像" class="headerlink" title="scratch空白镜像"></a><code>scratch</code>空白镜像</h6><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>coreos/etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h4 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a><code>RUN</code>执行命令</h4><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make wget'</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h3 id="build构建镜像"><a href="#build构建镜像" class="headerlink" title="build构建镜像"></a><code>build</code>构建镜像</h3><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><h4 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文(Context)"></a>镜像构建上下文(Context)</h4><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code>执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h4 id="其他docker-build用法"><a href="#其他docker-build用法" class="headerlink" title="其他docker build用法"></a>其他<code>docker build</code>用法</h4><h4 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h4><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:11.1.0-ce.0</span><br><span class="line">11.1.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h4 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190823104917.png" alt></p><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h4 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190823104953.png" alt></p><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190823105012.png" alt></p><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h4 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器的方式有两种:</p><ul><li>新建一个容器并启动</li><li>将终止状态(stopped)的容器重新启动</li></ul><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需命令<code>docker run</code></p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/054070DA-FD3E-43ae-9B21-2A80A8ED8596.png" alt></p><p><em>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</em></p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><blockquote><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ docker run ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt; hello world</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p></blockquote><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d  ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></span><br><span class="line">925cdc8f9b3916b68b222e6447daedf64137d3f2de54a0b6842c54475520901b</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker container logs</code> 查看)。</p><h4 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a><code>docker container logs</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [container ID or NAMES]</span><br></pre></td></tr></table></figure><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">925cdc8f9b39        ubuntu:18.04        "/bin/sh -c 'while t…"   41 seconds ago      Up 40 seconds</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/A4E1AB94-5B71-40ac-9F95-94B7B49D04A7.png" alt></p><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p><strong>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</strong></p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用<code>-d</code>参数时,容器启动后悔进入后台.</p><p>厚些时候需要进入容器进行操作时,可用的命令有<code>docker attach</code>以及<code>docker exec</code>,推荐使用<code>docker exec</code></p><h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -dit ubuntu</span></span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker attach 243c</span></span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818164032.png" alt></p><p><em>注意:如果在标准输入(stdin)中<code>exit</code>会导致容器的停止</em></p><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec</code>命令</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818163620.png" alt></p><p><strong>如果从这个 stdin 中 exit，不会导致容器的停止。</strong></p><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">"/bin/bash"</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><p><em>注：用户既可以使用 <code>docker load</code>来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照((<code>docker import</code>)文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件(<code>docker load</code>)将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm  trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165307.png" alt></p><h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190818165406.png" alt></p><h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821113928.png" alt></p><h4 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search centos</span></span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br></pre></td></tr></table></figure><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><h4 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull centos</span></span><br></pre></td></tr></table></figure><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure><h4 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h4><p>自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p><p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 或 <a href="https://bitbucket.org/" target="_blank" rel="noopener">BitBucket</a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p><p>要配置自动构建，包括如下的步骤：</p><ul><li>登录 Docker Hub；</li><li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li><li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li><li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li><li>指定 <code>Dockerfile</code> 的位置，并保存。</li></ul><p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="数据卷是什么"><a href="#数据卷是什么" class="headerlink" title="数据卷是什么?"></a>数据卷是什么?</h4><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker volume create my-vol</span></span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821145929.png" alt></p><h4 id="查看所有的数据卷"><a href="#查看所有的数据卷" class="headerlink" title="查看所有的数据卷"></a>查看所有的<code>数据卷</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821150024.png" alt></p><h5 id="查看指定数据卷的具体信息"><a href="#查看指定数据卷的具体信息" class="headerlink" title="查看指定数据卷的具体信息"></a>查看指定<code>数据卷</code>的具体信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821150127.png" alt></p><h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中<strong>可以挂载多个 <code>数据卷</code>。</strong></p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/wepapp \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821183635.png" alt></p><ul><li>使用<code>--mount</code>时如果引用了不存在的文件夹会报错<ul><li>引用了不存在的文件夹会报如下错误<code>docker: Error response from daemon: invalid mount config for type &quot;bind&quot;: bind source path does not exist: 某某不存在的文件夹.</code></li></ul></li><li>使用<code>-v</code>是如果引用了不存在的文件夹会自动创建</li></ul><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp,<span class="built_in">readonly</span> \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/opt/webapp <span class="comment"># touch new.txt</span></span><br><span class="line">touch: new.txt: Read-only file system</span><br></pre></td></tr></table></figure><h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/src/webapp"</span>,</span><br><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/opt/webapp"</span>,</span><br><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821183842.png" alt></p><h4 id="挂载一个本地文件作为数据卷"><a href="#挂载一个本地文件作为数据卷" class="headerlink" title="挂载一个本地文件作为数据卷"></a>挂载一个本地文件作为数据卷</h4><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line">1  ls</span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821184621.png" alt="运行容器"></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821184746.png" alt="容器内操作"></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190821184555.png" alt="打印bash_history文件结果"></p><p>这样就可以记录在容器输入过的命令了。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/16/使用Charles获取网易云网页端以及手机端的API地址/" class="post-title-link" itemprop="url">使用Charles获取网易云网页端以及手机端的API地址</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-16 21:41:42" itemprop="dateCreated datePublished" datetime="2019-08-16T21:41:42+08:00">2019-08-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-20 15:56:47" itemprop="dateModified" datetime="2019-08-20T15:56:47+08:00">2019-08-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="获取网页端网页云API地址"><a href="#获取网页端网页云API地址" class="headerlink" title="获取网页端网页云API地址"></a>获取网页端网页云API地址</h1><h2 id="启动Charles代理"><a href="#启动Charles代理" class="headerlink" title="启动Charles代理"></a>启动Charles代理</h2><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154655.png" alt></p><h2 id="捕获目标"><a href="#捕获目标" class="headerlink" title="捕获目标"></a>捕获目标</h2><h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154712.png" alt></p><h3 id="捕获目标-1"><a href="#捕获目标-1" class="headerlink" title="捕获目标!"></a>捕获目标!</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154703.png" alt></p><p>通过信息可以得出,网页端网易云音乐使用的接口为HTTPS,所以我们的下一步就是配置SSL,以捕获加密数据</p><h2 id="配置SSL"><a href="#配置SSL" class="headerlink" title="配置SSL"></a>配置SSL</h2><h3 id="安装Charles-SSL证书"><a href="#安装Charles-SSL证书" class="headerlink" title="安装Charles SSL证书"></a>安装Charles SSL证书</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154651.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154702.png" alt></p><ul><li>这里的过程非常容易,下一步即可,不做过多赘述</li></ul><h3 id="在Charles启用对https-music-163-com的SSL代理"><a href="#在Charles启用对https-music-163-com的SSL代理" class="headerlink" title="在Charles启用对https://music.163.com的SSL代理"></a>在Charles启用对<code>https://music.163.com</code>的SSL代理</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154701.png" alt></p><h4 id="对目标进行锁定"><a href="#对目标进行锁定" class="headerlink" title="对目标进行锁定"></a>对目标进行锁定</h4><p>计算机在无时不刻发送数据,导致我们的Charles非常清爽,所以我们需要锁定目标</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154700.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154650.png" alt></p><p>是不是清爽了许多!!</p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ul><li>在刷新网易云音乐页面后提示页面不安全,可能被攻击.嗯,从某种意义来说就是这样,我们不管他</li></ul><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154654.png" alt></p><ul><li>观察api请求结构</li></ul><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154659.png" alt></p><ul><li>锁定目标</li></ul><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154710.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>获取音乐本体URL的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params:HfkwofZ8nsUxNEBLvPBxyrliRdcVJ+zP2fsiziSHhAN5OHPlQrjJPlMvBdv75FWMVyPL59fnorFkThrphcqrmICEgJEXzOUgop6FbwGaCPtJxmh9raoYNuUMxBqNpu9PD15IXmaiVxmhTjg6AnSfHg==</span><br><span class="line">encSecKey:5ef720b71a5307a47eb34a7ec3e1862f75d355a673d3a452354c168db11869d2e65d09e1a098f62a30cec61092622b62aa8ecff3d3b5ac556ef76eaaecd7776bb71b2a278852e9f5665212feefb094a573f0215ee9d44fc909fef5e5cefdd5bb795d4023f0d543f8763337fe10e9fbe66f650fe620d29e440cc0afb8f0f7f5ad</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154707.png" alt></p><h1 id="获取安卓网易云APP-API地址"><a href="#获取安卓网易云APP-API地址" class="headerlink" title="获取安卓网易云APP-API地址"></a>获取安卓网易云APP-API地址</h1><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154656.png" alt></p><ul><li>将手机置于和pc同一局域网下</li></ul><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154714.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154652.png" alt></p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154657.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154653.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154711.jpg" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154713.jpg" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154709.jpg" alt></p><p>√Done!</p><h2 id="正式开始-1"><a href="#正式开始-1" class="headerlink" title="正式开始"></a>正式开始</h2><p>在刷新几次页面后观察列表,发现<code>interface.music.163.com</code>的接口结构和刚刚网页端网易云音乐的目标接口接口及其相似</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154708.png" alt></p><p>几次尝试之后锁定了<code>http://interface3.music.163.com/eapi/song/enhance/player/url/v1?ids=%5B%22536622304_0%22%2C%22537470060_0%22%5D&amp;level=exhigh&amp;encodeType=aac</code></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154704.png" alt></p><p>不过这以大坨是什么东西..</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154658.png" alt></p><p>内容编码格式为gzip,难道和这个有关?</p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154705.png" alt></p><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154706.png" alt></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>API本体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://interface3.music.163.com/eapi/song/enhance/player/url/v1?ids=%5B%22536622304_0%22%2C%22537470060_0%22%5D&amp;level=exhigh&amp;encodeType=aac</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params=FA90B329E9614F79E79598F37DC2EDB487F00D1BC4C9B24CD57E6C318B90735683B31EBCEA2406A063CEA88FC25A3AF31F5AE062C154E354DE501E2FABA37F00CD5764981144AC2E56A8AC59D6F4133F6F4461CDA1CF73753380189AA21E8AB50A123DFC9CAB93F40C935CF84CD10D6DF5B2D7DA80ADA61A7F7F5A2F3A608221553A5F9DB5944F3CC013987127041C75588E1634CC12A893E605B06325FC92A516D1E588E00C3DCE6E0A53EB173D39F97CA037707AB40CCF7F93044ACBD8235C03ADE6CC06114148244F5C19DA7905873D4997C8C78628031375F49E8B68CB93327B9206F391DC49E69F1672B30605CD4F5B95AC55800D593466BE116C870A0E8AB62C7BDC11091FF435E59684EB7E277DB6812B495A61571B7CAF8C54EF7456881F67FE66B6FCCADFF268EDD4A4C4DB1517E05A2D5EC0E61A2039C1E79CD007315D001712F055117E10CD02B8438A56BABDB0E88EAD74FA6873025EFE3BF1EB4111ED282DB085F3DE47325A84ADDC879815CD43514120820C821D1648CB1DE16446514C72161B30F1B77E72CC011770CF5B8DD0C0B7FD127C526211D4B3FF74DCB5494E0ABC6A2DB7AA5211661612491D569742CDEF98F112244CAB8EDAA831D0453954A3B7FFC43C1D2CFA21DA4D82C89D8DD2D46E5E0BA1FBE8DF6E956BF54894D9CF7EC29C4A84CF5D4AF27D1B758048AF9D3CE4BF3189ABEBB0E7015B60B460EFFBD617C78448B4470C6B53A198529E2E9860A3E4012D6419579E81686A6C997E67CE2E4C5E7256D5C9B731C1149D7E72EBF4E414922DF6A739ED34ED7F6EEC5F8B757E2D1C6C187F613118ED4386870F333EFF03967845824CEB3390B7D8BAA052F1854D973C4F33312C905A8F593736B9D1B3B7776053D997B7247F02D8123DF0F56A7C53FC2BFBE9BBBA376D6343AB55D372C515C620A1EFCC126D18</span><br></pre></td></tr></table></figure><p>根据返回的这一大坨来看,应该不是服务器报错,但是我们看到的依然是乱码,基本上可以判定该接口返回的数据为加密数据.</p><h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154706.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="网页端API接口"><a href="#网页端API接口" class="headerlink" title="网页端API接口"></a>网页端API接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params:HfkwofZ8nsUxNEBLvPBxyrliRdcVJ+zP2fsiziSHhAN5OHPlQrjJPlMvBdv75FWMVyPL59fnorFkThrphcqrmICEgJEXzOUgop6FbwGaCPtJxmh9raoYNuUMxBqNpu9PD15IXmaiVxmhTjg6AnSfHg==</span><br><span class="line">encSecKey:5ef720b71a5307a47eb34a7ec3e1862f75d355a673d3a452354c168db11869d2e65d09e1a098f62a30cec61092622b62aa8ecff3d3b5ac556ef76eaaecd7776bb71b2a278852e9f5665212feefb094a573f0215ee9d44fc909fef5e5cefdd5bb795d4023f0d543f8763337fe10e9fbe66f650fe620d29e440cc0afb8f0f7f5ad</span><br></pre></td></tr></table></figure><h2 id="移动端API接口"><a href="#移动端API接口" class="headerlink" title="移动端API接口"></a>移动端API接口</h2><p>API本体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://interface3.music.163.com/eapi/song/enhance/player/url/v1?ids=%5B%22536622304_0%22%2C%22537470060_0%22%5D&amp;level=exhigh&amp;encodeType=aac</span><br></pre></td></tr></table></figure><p>请求参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params=FA90B329E9614F79E79598F37DC2EDB487F00D1BC4C9B24CD57E6C318B90735683B31EBCEA2406A063CEA88FC25A3AF31F5AE062C154E354DE501E2FABA37F00CD5764981144AC2E56A8AC59D6F4133F6F4461CDA1CF73753380189AA21E8AB50A123DFC9CAB93F40C935CF84CD10D6DF5B2D7DA80ADA61A7F7F5A2F3A608221553A5F9DB5944F3CC013987127041C75588E1634CC12A893E605B06325FC92A516D1E588E00C3DCE6E0A53EB173D39F97CA037707AB40CCF7F93044ACBD8235C03ADE6CC06114148244F5C19DA7905873D4997C8C78628031375F49E8B68CB93327B9206F391DC49E69F1672B30605CD4F5B95AC55800D593466BE116C870A0E8AB62C7BDC11091FF435E59684EB7E277DB6812B495A61571B7CAF8C54EF7456881F67FE66B6FCCADFF268EDD4A4C4DB1517E05A2D5EC0E61A2039C1E79CD007315D001712F055117E10CD02B8438A56BABDB0E88EAD74FA6873025EFE3BF1EB4111ED282DB085F3DE47325A84ADDC879815CD43514120820C821D1648CB1DE16446514C72161B30F1B77E72CC011770CF5B8DD0C0B7FD127C526211D4B3FF74DCB5494E0ABC6A2DB7AA5211661612491D569742CDEF98F112244CAB8EDAA831D0453954A3B7FFC43C1D2CFA21DA4D82C89D8DD2D46E5E0BA1FBE8DF6E956BF54894D9CF7EC29C4A84CF5D4AF27D1B758048AF9D3CE4BF3189ABEBB0E7015B60B460EFFBD617C78448B4470C6B53A198529E2E9860A3E4012D6419579E81686A6C997E67CE2E4C5E7256D5C9B731C1149D7E72EBF4E414922DF6A739ED34ED7F6EEC5F8B757E2D1C6C187F613118ED4386870F333EFF03967845824CEB3390B7D8BAA052F1854D973C4F33312C905A8F593736B9D1B3B7776053D997B7247F02D8123DF0F56A7C53FC2BFBE9BBBA376D6343AB55D372C515C620A1EFCC126D18</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/16/Into-Hexo-Blog-Inset-Image/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/16/Into-Hexo-Blog-Inset-Image/" class="post-title-link" itemprop="url">Into Hexo Blog Inset Image</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-16 20:54:12" itemprop="dateCreated datePublished" datetime="2019-08-16T20:54:12+08:00">2019-08-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-08-20 15:45:28" itemprop="dateModified" datetime="2019-08-20T15:45:28+08:00">2019-08-20</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="在Hexo博客中添加图片"><a href="#在Hexo博客中添加图片" class="headerlink" title="在Hexo博客中添加图片"></a>在Hexo博客中添加图片</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在Hexo博客根目录安装<code>hexo-asset-image</code>插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> npm install hexo-asset-image --save#我信你个鬼,这个版本太老了,用下面的命令</span><br><span class="line">npm install https://github.com/xcodebuild/hexo-asset-image.git</span><br></pre></td></tr></table></figure><h2 id="配置自动创建文件夹"><a href="#配置自动创建文件夹" class="headerlink" title="配置自动创建文件夹"></a>配置自动创建文件夹</h2><p>在<code>_config.yml</code>修改<code>post_asset_folder: true</code>以在创建新文章的时候自动创建同名文件夹</p><h2 id="图片效果展示"><a href="#图片效果展示" class="headerlink" title="图片效果展示"></a>图片效果展示</h2><p><img src="/images/loading.svg" data-original="https://oss.trustme.anyingiit.com/images/20190820154425.jpg" alt></p><p>注:博主后来使用了阿里的OSS桶,使用插件毕竟还有弊端,会导致某些插件不能正确配置.</p><h1 id="等等-好像没那么容易结束…"><a href="#等等-好像没那么容易结束…" class="headerlink" title="等等!好像没那么容易结束…"></a>等等!好像没那么容易结束…</h1><p>原本文章在这里就结束了,作者本来只想简单的记录一下设置图片的过程,没想到踩了一个大坑!也许你注意到了,上面的安装<code>hexo-asset-image</code>的代码第一行被注释掉了,作者弄了两个小时,就是无法生成正确的引用图片地址,气死我了,各种升级依赖,各种google,然后发现就是以前的版本有一个生成Bug,导致图片的位置一直引用的地址为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src="/.com//xxPic.jpg"</span><br></pre></td></tr></table></figure><p>气死我了,希望看到文章的您不要再使用<code>npm install hexo-asset-image --seve</code>了!!</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/13/解决解析域名到xxx-github-io后一提交就会导致绑定失效/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/13/解决解析域名到xxx-github-io后一提交就会导致绑定失效/" class="post-title-link" itemprop="url">解决解析域名到xxx.github.io后一提交就会导致绑定失效</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-13 11:38:03 / Modified: 11:39:17" itemprop="dateCreated datePublished" datetime="2019-08-13T11:38:03+08:00">2019-08-13</time></span></div></header><div class="post-body" itemprop="articleBody"><p>​ 经过多方排查,最终发现是我的source目录下的CNAME错误的写成了”CHAME”导致的,更名重新提交后文件解决~</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://trustme.anyingiit.com/2019/08/12/Hello-World/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="John Doe"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="AnYing Blog By Hexo"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a href="/2019/08/12/Hello-World/" class="post-title-link" itemprop="url">Hello World</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-08-12 21:15:56 / Modified: 21:22:41" itemprop="dateCreated datePublished" datetime="2019-08-12T21:15:56+08:00">2019-08-12</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>欢迎你,陌生人</p><p>当你看到该页面时说明我已经成功利用github创建了一个Hexo博客站点,而您能看到这个这个标题说明我对如下操作有了了解:</p><ul><li>Linux 的基本使用</li><li><em>Markdown语法的</em>基本使用</li><li><code>npm</code>的基本使用</li><li><code>hexo</code>的基本使用</li><li>域名基本的解析</li><li>对博客结构有一定了解</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">John Doe</p><div class="site-description motion-element" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">6</span> <span class="site-state-item-name">tags</span></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">John Doe</span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script><script src="/js/schemes/muse.js?v=7.3.0"></script><script src="/js/next-boot.js?v=7.3.0"></script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body></html><!-- rebuild by neat -->